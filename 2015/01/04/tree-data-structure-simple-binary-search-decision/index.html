<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Rollin' Trees, yo</title>
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,400,300,600,700' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans+Condensed:300' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="http://clarkfeusier.com/css/base.css">
    <link rel="shortcut icon" type="image/x-icon" href="http://clarkfeusier.com/img/favicon.ico" />
    <script type="text/javascript" src="http://clarkfeusier.com/vendor/syntaxhighlighter_3.0.83/scripts/shCore.js"></script>
    <script type="text/javascript" src="http://clarkfeusier.com/vendor/syntaxhighlighter_3.0.83/scripts/shBrushSql.js"></script>
    <script type="text/javascript" src="http://clarkfeusier.com/vendor/syntaxhighlighter_3.0.83/scripts/shBrushRuby.js"></script>
    <script type="text/javascript" src="http://clarkfeusier.com/vendor/syntaxhighlighter_3.0.83/scripts/shBrushBash.js"></script>
    <script type="text/javascript" src="http://clarkfeusier.com/vendor/syntaxhighlighter_3.0.83/scripts/shBrushYaml.js"></script>
    <script type="text/javascript" src="http://clarkfeusier.com/vendor/syntaxhighlighter_3.0.83/scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="http://clarkfeusier.com/vendor/syntaxhighlighter_3.0.83/scripts/shBrushJScript.js"></script>
    <link href="http://clarkfeusier.com/vendor/syntaxhighlighter_3.0.83/styles/shCore.css" rel="stylesheet" type="text/css" />
    <link href="http://clarkfeusier.com/vendor/syntaxhighlighter_3.0.83/styles/shThemeDefault.css" rel="stylesheet" type="text/css" />
</head>
<body>
    <!-- Google Tag Manager -->
    <noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-P9FNCG" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0], j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-P9FNCG');
    </script>
    <!-- End Google Tag Manager -->
    <!-- Setup SyntaxHighlighter -->
    <script type="text/javascript">SyntaxHighlighter.all()</script>
    <!-- End SyntaxHighlighter Setup -->
    <header>
        <div id="logo">
            <img src="http://clarkfeusier.com/img/headshot.png" alt="">
        </div>
        <div id="site-heading">
            <h2 class="title">Clark Feusier</h2>
            <h3 class="subtitle">Software Engineer and Metalogician</h3>
        </div>
        <ul id="nav">
         <li class=""><a href="http://clarkfeusier.com/pages/about">About</a></li>
         <li class=""><a href="http://clarkfeusier.com/index.html">Writing</a></li>
         <li class=""><a href="http://clarkfeusier.com/pages/portfolio">Portfolio</a></li>
         <li><a href="#" id="contact-section">Contact</a></li>
     </ul>
     <div id="contact-wrapper">
        <div id="contact-content">
            <ul id="contact-list">
                <i class="fa fa-envelope-o contact-icon"></i>
                <li><a href="mailto:cfeusier@gmail.com">  cfeusier@gmail.com</a></li>
                <li class="separator">/</li>
                <li><a href="http://github.com/cfeusier"><i class="fa fa-github"></i></a></li>
                <li><a href="http://twitter.com/clarkfeusier"><i class="fa fa-twitter"></i></a></li>
                <li><a href="http://facebook.com/cfeusier"><i class="fa fa-facebook"></i></a></li>
                <li><a href="http://linkedin.com/in/clarkfeusier"><i class="fa fa-linkedin"></i></a></li>
            </ul>
        </div>
        <a href="#" id="contact-close"><i class="fa fa-times"></i></a>
    </div>
</header>
<div id="main-contents">
<div class="single-post">
    <div class="container">
        <div class="post-item">
            <div class="post-header">
                <div class="blog-no-header"></div>
            </div>
            <div class="post-body">
                <div class="meta">
                    <span class="date">04 January 2015</span>
                </div>
                <h2 class="title">Rollin' Trees, yo</h2>
                <div class="content">
                    <p>I like trees. All kinds of trees — concrete and abstract. Redwoods, Oaks, search trees, decision trees, fruit trees, DOM trees, Christmas trees, and more.</p>

<p>They are powerful beyond common recognition. Oxygen, life, shelter, food, beauty, computational efficiency, and more are provided by trees when we interact with them in the right ways.</p>

<p>Don’t get offended when I say this:</p>

<blockquote>you don't like trees enough</blockquote>

<p>Before I can make you feel bad about taking trees for granted, I need you to be very familiar with trees and their uses. Once you understand the tree, you will feel bad for not appreciating it enough. Then, you will start appreciating trees, as well as using them in the situations for which they are perfectly suited. Good.</p>

<hr />

<h3 id="the-tree-as-an-abstract-data-type">The Tree as an Abstract Data Type</h3>

<p>A tree is, first and foremost, a data structure adhering to the interface of the abstract data type <strong>Tree</strong>. A Tree is just an abstract <em>ideal</em> that we all kind of agree upon — hey buddy, let’s call any data structure that has property X, Y, and Z an <strong><em>array</em></strong>, while any data structure with properties A, B, and L should be called a <strong><em>tree.</em></strong></p>

<p>Why is this important? Because it helps us avoid a common mental mistake, early — that of confusing the abstract data type <strong>Tree</strong> with a particular concrete implementation of that abstraction. Can you implement the basic properties of ‘Treehood’ in more than one way? If you answered yes, you are ready to continue. If not, please read about the differences between a concrete entity and an abstraction.</p>

<h3 id="the-tree-as-a-concrete-data-structure">The Tree as a Concrete Data Structure</h3>

<p>A tree, like all data structures, holds data and has certain data-access rules. Like all data structures, a tree will have tradeoffs related to lookup, insertion, removal, and similar operations. So, the real questions:</p>

<blockquote>1. what data does a tree hold?</blockquote>
<blockquote>2. how is that data accessed and manipulated?</blockquote>
<blockquote>3. what tradeoffs are associated with a standard tree implementation?</blockquote>

<p>Let’s try to answer those three questions.</p>

<h2 id="data-arrangement">Data Arrangement</h2>

<p>The tree is often called a ‘node-based data structure,’ like a linked-list or graph — this is just to say that a tree is composed of <strong><em>nodes</em></strong>, where each node stores a value and reference to zero or more other nodes. The tree is distinguished from the other node-based data structures by the constraint that there is a root node and each other node is an ancestor of the root node. This allows the data structure to simulate a tree-like hierarchy that we are used to conceptualizing in disciplines like taxonomy.</p>

<p>Another interesting feature of the tree structure is that each node of a tree is itself a subtree with its own children nodes, making the tree particularly well-suited for interaction with recursion to solve certain types of problem.</p>

<p>Summary:</p>

<ol>
  <li>a tree is composed of <strong>nodes</strong></li>
  <li>a tree has a <strong>root node</strong></li>
  <li>each node has a <strong>value</strong> of any data type</li>
  <li>a root node has <strong>ancestor nodes</strong> stored as a list with no duplicates and without the root node itself</li>
  <li>all nodes are <em>themselves trees</em></li>
</ol>

<p>With that summary in mind, here is a simple tree visualization:</p>

<div style="text-align: center;"><img class="treeImg" src="/img/simple_tree.png" style="width: 80%; height: 400px; margin: 10px auto; border: 1px solid gray;" /></div>

<p>In our case, the top node is the ‘root’ of our tree, storing a value of 1. In this tree, the values being stored at each node are numbers, though this need not be the case. Finally, our root node has 11 ancestors, with only 4 ancestors that are children.</p>

<p>Armed with a firm grasp of the concept of a tree, we can proceed to define the basic structure of a tree implementation.</p>

<h2 id="implementation-step-1---tree-structure">Implementation Step 1 - Tree Structure</h2>

<p>We are going to create a Tree ‘class,’ from which we can create specific instances of a tree.</p>

<script src="https://gist.github.com/Cfeusier/16f16c0e37666aa782af.js"></script>

<p>Our <strong>Tree</strong> constructor function takes a single input (the value for the root node). This function will assign the input value to a property on the tree instance, as well as create an empty array to store the children of this root node.</p>

<p>We can now create tree instances right and left (though they will currently lack tree functionality). For example, we don’t have an interface for adding children or checking if a tree contains a child with a given value. But for now, we can at least create trees, like so:</p>

<script src="https://gist.github.com/Cfeusier/3ca9a83eaf46c8199cd7.js"></script>

<p>Now that we can make trees, let’s give them a useful interface.</p>

<h2 id="data-access-and-manipulation---the-basic-interface-of-a-tree">Data Access and Manipulation - the Basic Interface of a Tree</h2>

<p>Most agree that a useful tree implementation will at least offer an interface for the following:</p>

<ol>
  <li>adding a child node to a tree</li>
  <li>checking if a child node is in a tree</li>
</ol>

<p>Those two operations provide a basis for building some cool functionality with your trees, as well as a basis for extension and reuse in other contexts.</p>

<p>Let’s start with adding a node to a tree’s children.</p>

<script src="https://gist.github.com/Cfeusier/dc1110464f9760b7f352.js"></script>

<p>This code is pretty easy to follow:</p>

<ul>
  <li>we are adding a method called <strong><em>addChild</em></strong> to the <strong>Tree</strong> .prototype property</li>
  <li>the <strong><em>addChild</em></strong> method takes a single parameter — the value with which to initialize the child tree</li>
  <li>the <strong><em>addChild</em></strong> method pushes a new instance of a Tree initialized with the child value into the children array of the current tree</li>
</ul>

<p>Next, let’s add a method for checking if a tree contains a node with a target value.</p>

<script src="https://gist.github.com/Cfeusier/83a7893e78e0610e7ea1.js"></script>

<p>This operation is slightly more complex than <strong><em>addChild</em></strong> because it uses recursion to search through the tree — don’t be alarmed. Let’s break it down.</p>

<ul>
  <li>we are adding a method called <strong><em>contains</em></strong> to the <strong>Tree</strong> .prototype property</li>
  <li>the <strong><em>contains</em></strong> method takes two parameters — a target value for which to search the tree and a root node (tree) with which to start the search</li>
  <li>the <strong><em>contains</em></strong> method assigns the root to the root argument passed in or defaults to the current tree</li>
  <li>the <strong><em>contains</em></strong> method sets up a base case to break out of the recursion that we are going to create — if the value at the current root is equal to the target value, we have found the target, i.e., the tree contains the target value</li>
  <li>the <strong><em>contains</em></strong> method iterates through the children of the current root node, recursively invoking the <strong><em>contains</em></strong> method with the same target value to search for, but with a new root tree to search — the child node that is currently being examined in the iteration</li>
  <li>if the recursive call for that child node returns truthy, we know that we have found the target value in that child tree somewhere, so we return true</li>
  <li>finally, if we have searched all of the children trees and not hit our base case, we will return false because we haven’t found the target value anywhere within our tree</li>
</ul>

<p>This type of recursion through a tree’s children is common. Let’s look at a real-world example of a tree and a function that searches that tree in a similar fashion as our <em>contains</em> method.</p>

<h3 id="the-dom-tree-and-a-getelementsbyclassname-polyfill">The DOM Tree and a getElementsByClassName Polyfill</h3>

<p>The DOM is a tree-like structure. Though the DOM is highly optimized, it still has certain properties that allow me to use it as an example of a simple tree.</p>

<p>The Document Object Model (DOM) is used in the browser to model an HTML document. The HTML document is represented as a tree of nodes, where each node is an object representation of an HTML element. The root of the tree is the <code>document</code>, which usually has at least two children — <code>head</code> and <code>body</code>.</p>

<p><code>head</code> and <code>body</code> are themselves tree-like structures that contain child nodes. Each of those child nodes is also a sub-tree, <em>ad infinitum</em>. Sounds like our simple tree from earlier, right?</p>

<p>If the DOM can be thought of as a tree, then we would assume that some of the DOM API would be similar to the tree interface described above. We would guess that we can search the DOM tree for a given node or a given feature of a node. We would also guess that we can insert child nodes into the DOM tree.</p>

<p>In both cases, we would be correct. I am going to focus on the case of searching the DOM tree, to parallel our <em>contains</em> method from above.</p>

<p>There is a JavaScript method called <code>Document.getElementsByClassName()</code>, which searches the document (or any root element) for all of the elements that have a target class name. All elements that have the target classname will be returned from the method call in an array. If no elements are found, the array will be empty.</p>

<p>Let’s imagine that we had to write a <em>getElementsByClassName</em> function that mimicks the above functionality.</p>

<script src="https://gist.github.com/Cfeusier/6741763da15e735e09d7.js"></script>

<p>This looks pretty similiar to the <em>contains</em> method that we wrote above. Here is a line-by-line description:</p>

<ul>
  <li>line 1: declare global function <em>getElementsByClassName</em>
    <ul>
      <li><em>getElementsByClassName</em> takes two parameters — a className to search for and a root node from which to start the search</li>
    </ul>
  </li>
  <li>line 2: declare nodes variable and initialize to an empty array — will store nodes with matching className</li>
  <li>line 3: assign the node variable to whatever is passed in, or fallback to the <code>document.body</code> node</li>
  <li>line 5: get all of the class names for the current root node by splitting the <code>node.className</code> on whitespace</li>
  <li>line 8: using <em>indexOf</em>, check if the target class name is contained in the list of node’s class names</li>
  <li>line 9: if the target class name was present, push the current node into the matching <code>nodes</code> array</li>
  <li>lines 13 - 16: check children of current node for target class name
    <ul>
      <li>line 13: iterate the length of the current node’s list of children</li>
      <li>line 14: for each child, create a variable <code>childResults</code> initialized to the result of invoking <code>getElementsByClassName</code> with the child as the root node from which to start searching</li>
      <li>line 15: reassign <code>nodes</code> to the current <code>nodes</code> collection concatenated with the <code>childResults</code> from each child</li>
    </ul>
  </li>
  <li>line 18: return the collection of DOM nodes that have the class name for which the method is searching</li>
</ul>

<p>By now you should feel comfortable with the simple tree and how it can be used. We aren’t going to stop here though, because the simple tree actually sucks. It is inefficient and rarely used. Let’s discuss the tradeoffs associated with the simple tree.</p>

<h2 id="tradeoffs">Tradeoffs</h2>

<h3 id="simple-tree">Simple Tree</h3>

<p>The simple tree implementation above was for pedagogical purposes, but now let’s examine the costs of this type of tree implementation to see if we can get any clues as to why a simple tree like this is <em>rarely</em> used compared to a more ‘constrained’ tree like a search tree or decision tree.</p>

<p>The time complexity of the <strong><em>addChild</em></strong> operation is <strong>constant</strong>, so we will ignore <strong><em>addChild</em></strong> for now.</p>

<p><strong><em>contains</em></strong> is disgusting when it comes to worst-case time complexity. <strong><em>contains</em></strong> iterates through <em>n</em> children, and for each of those iterations, it recurses into checking the children of the current child. This type of recursion nested within iteration is costly — <strong>polynomial</strong> to <strong>exponential</strong>.</p>

<p>So, how do we change this costly search operation? How do we make a tree that is optimized to search? Constraints.</p>

<p>The time cost can be greatly reduced by adding constraints to our tree. We could constrain the children. We could also constrain the way that nodes are added to the tree, in order to make it more efficient to search.</p>

<h2 id="binary-search-tree">Binary Search Tree</h2>

<p>A common type of tree in computer science is the <em>binary search tree</em>. This tree is similar to the simple tree, but it has a two new constraints:</p>

<ol>
  <li>each node can only have 2 children (binary)</li>
  <li>each node on one side of the tree has one of the possible values of a given binary property, while each node on the other side of the tree has the inverse value for that same given binary property</li>
</ol>

<p>Let’s keep it simple by using ‘greater than’ and its inverse ‘less than’ as our binary properties.</p>

<p>So, a binary search tree has a root node. That node can have 0 to 2 children. The ‘left’ child will have a value <em>less than</em> our root node, while the ‘right’ child will have a value <em>greater than</em> our root node.</p>

<p>Here is a binary search tree that fulfills those constraints:</p>

<p><img src="/img/binary_search_tree_1.png" /></p>

<p>If I asked you to insert a node with a value of 2 into the tree, where would you put it?</p>

<p>The correct answer is the far left, as the left child of the node with a value of 3. 2 is less than the root value 4, so you look left. 2 is less than the value of 3, so you look left again. You find no more nodes so you insert a node with a value of 2.</p>

<p><img src="/img/binary_search_tree_2.png" /></p>

<p>You had to check multiple times to make sure that you <em>put</em> the new node in the correct place. This is a constraint on <em>insertion</em>. The binary search tree constrains insertion of new nodes because it is optimized for <em>search</em> — by putting things in a principled order, you can search and retrieve things back out faster than if the tree was unordered. However, the constraints on insertion take <strong>time</strong> compared to the simple tree that pushed new nodes onto its list of children without checking where to put them. This means that the binary search tree is optimized for <em>read</em> situations and not <em>write</em> situations. So, you would use it in a situation where you need speed for high-frequency search of large data, where you don’t have to write new data to the tree very often (or if you do, it can happen asynchronously in the background with no user waiting on the result). This happens surprisingly often.</p>

<p>Let’s look at the tree in action on search. Let’s say I asked you if your tree contained a node with a value of 2, or if I asked you to return the node with a value of 2 if it exists in your tree?</p>

<p>Step 1, check the root of the tree. Is the root value equal to 2? If not, is 2 less than the root’s value?</p>

<p><img src="/img/binary_search_tree_3.png" /></p>

<p>The root value is 4, so 2 is less than the root node’s value. This means that we need to go look at the left child of the root node, and repeat the process that we just did with the root node. We also get to eliminate the whole right side of the tree because we know that everything on that side is greater than our root node’s value of 4. So, we can ask, is the root’s left child value equal to 2? If not, is 2 less than the root’s left child value?</p>

<p><img src="/img/binary_search_tree_4.png" /></p>

<p>As you can see, in our case 2 is less than the root’s left child value (3). We can now go down a level in the tree and check the value of the root’s left child’s left child :) Is the value of the left child of the left child of the root equal to 2? If not, is it less than 2?</p>

<p><img src="/img/binary_search_tree_5.png" /></p>

<p>In our case, the value at this node in our tree is equal to our target value of 2, so we can either return true (tree contains value) or return the node itself (node value matches query for node with matching value).</p>

<p>Ok, so that might not seem very impressive, but imagine if your tree (data set) contained millions of nodes. If the tree is balanced like ours, than your first check would possibly cut the query set in half. That is a huge cost cut in time complexity.</p>

<p>Enough theory, you say! Show us the code! Ok, fair enough.</p>

<h3 id="one-possible-implementation-of-a-binary-search-tree">One Possible Implementation of a Binary Search Tree</h3>

<script src="https://gist.github.com/Cfeusier/b32acb59cb0dfdbf5706.js"></script>

<p>Pretty simple, with heavy dose of recursion. I am going to do a line-by-line, and then discuss the time complexity.</p>

<ul>
  <li>lines 1 - 5: BinarySearchTree constructor function
    <ul>
      <li>initializes value property to passed in argument value</li>
      <li>defaults the left and right child properties to null</li>
    </ul>
  </li>
  <li>lines 7 - 30: BinarySearchTree insert instance method
    <ul>
      <li>lines 9 - 11: throws error if you try to insert a duplicate value into the tree</li>
      <li>line 14: checks if the value to insert is less than the root value</li>
      <li>line 15: checks if the left child of the root is empty</li>
      <li>line 16: if empty, inserts a new BinarySearchTree with the passed in argument value</li>
      <li>line 18: if the left child has a value, try to insert the passed in argument value into the left child</li>
      <li>lines 23 - 29: run the inverse of lines 9 - 11 for the other side of the tree if the passed in argument value was greater than the root’s value</li>
    </ul>
  </li>
  <li>lines 32 - 50: BinarySearchTree contains instance method
    <ul>
      <li>lines 34 - 36: return true if your root value is equal to the target value
        <ul>
          <li>this is the base case</li>
        </ul>
      </li>
      <li>lines 38 - 41: if the value at the root is less than the target value, then you want to check the right side of the subtree
        <ul>
          <li>if the right child of the root isn’t empty, you want to recurse down that side of the tree to see if it contains the target value</li>
        </ul>
      </li>
      <li>lines 43 - 46: if the value at the root is greater than the target value, then you want to check the left side of the subtree
        <ul>
          <li>if the left child of the root isn’t empty, you want to recurse down that side of the tree to see if it contains the target value</li>
        </ul>
      </li>
      <li>line 49: return false if the target value wasn’t found</li>
    </ul>
  </li>
</ul>

<p>Compared to the simple tree <strong>contains</strong> method, the time complexity of the binary search tree <strong>contains</strong> method is beautiful. All of the comparisons are done in constant time and the recursion is the only linear operation. So, at worst, this search method is <strong>linear</strong>, compared to the exponential time complexity of the simple tree.</p>

<p>Now that we have built the foundations of the tree and binary search tree, let’s finish this post by examining a very popular use of a special type of tree — <strong>the decision tree</strong>.</p>

<hr />

<h2 id="the-decision-tree">The Decision Tree</h2>

<p>A decision tree is a tree where each node value is dependent on a decision made at a parent node. Sounds abstract, but it is actually pretty intuitive. The tree branches are ‘decision sequences,’ i.e., paths which the decision could take. The key to understanding the decision tree is grasping the idea that each node represents a possible system state. And, each possible system state is determined by its parent’s state.</p>

<p>For example, I am confronted with some choices — dinner or dessert?</p>

<p>If I choose dinner, I am confronted with a new decision point — chicken or steak?</p>

<p>If I choose chicken, I am confronted with a new decision point — fried chicken or chicken marsala?</p>

<p>This could continue as long as we want. Each of the decisions was dependent on the first choice between dinner or dessert. If I had chosen ‘dessert,’ the resulting choices to choose between would have been different than what was offered based on my original decision of ‘dinner.’</p>

<p>We can visualize this example with a decision tree:</p>

<p><img src="/img/blog/trees.png" /></p>

<p>The decision tree will usually contain <strong>n * r + 1 nodes</strong>, where n is the number or possible choices at each decision point and r is the number of decision points. So, if you have to choose between dinner and dessert, and you only have to make that decision once, then your decision tree would have 3 nodes — one node for each choice (2 nodes total) multiplied by one (number of times you need to make the decision), plus 1.</p>

<p>Humans use this type of ‘branched’ reasoning all the time — don’t let all of the new terminology convince you that a decision tree is anything other than a representation of our standard ‘decision-making’ process.</p>

<p>Look at the tree while imagining that you are sitting in a restaurant with a menu in front of you. The first decision point that you reach is a choice between ordering <em>dinner</em> or <em>dessert</em> (not both, we are strict).</p>

<p>Let’s assume that you want to eat dinner. You will move down a level in the tree to the ‘dinner’ node. Your mind will now prompt you to make another decision — should you order <em>chicken</em> or <em>steak</em> for dinner?</p>

<p>For some reason, you don’t eat red meat, so you decide that you want to have chicken for dinner. Move your focus down to the ‘chicken’ node, and now choose between <em>fried</em> chicken, chicken <em>marsala</em>, or a <em>curry</em> chicken. You love curries, so you move down another node to choose between <em>red</em> and <em>yellow</em> curry.</p>

<p>Once you have made all of the decisions necessary to answer the original question — what you are going to order — you can package up that information into an answer and give it to the server.</p>

<p>But, what is ‘that information’ that you need to package up, and where do you get it?</p>

<p>This is why decision trees are beautiful — your <strong>order</strong> decision is actually contained within the tree, defined by the <em>sequence</em> of decisions made while traversing the tree. The path that you took is actually your order! You can think of your order as <strong>dinner -&gt; chicken -&gt; curry -&gt; yellow</strong>, i.e., the values at each of the nodes that were chosen.</p>

<p>Pretty cool, eh?</p>

<p>In reality, our decision-making might require us to go up and down the tree, as well as across the tree, before we can decide on the best final path that we want to take. When we need to do this in our programs, we can harness the properties of the decision tree and use recursion to crawl all over the tree.</p>

<p>You can solve many (software) problems by using a combination of recursion and a decision tree — so, let’s see an example!</p>

<p>At first, I was going to show you my solution to the <strong>n-queens</strong> problem in order to demonstrate the use of a decision tree, but then I realized how stupid that would be from a pedagogical perspective, due to the complexity of n-queens. I will save n-queens for a separate post. Instead, we are going to use a common toy interview problem based on the <strong>rock-paper-scissors</strong> (row-sham-bo) game, which isn’t novel but manifests some lessons about using decision trees for system-state analysis.</p>

<hr />

<h3 id="rock---paper---scissors">Rock - Paper - Scissors</h3>

<blockquote>Prompt: generate an array of all possible throws a single player could throw for n rounds</blockquote>

<p>Constraints of the problem:</p>

<ul>
  <li>single player</li>
  <li><strong>n</strong> rounds</li>
  <li>3 possible throws — <em>rock</em>, <em>paper</em>, or <em>scissors</em></li>
  <li>return an array of arrays
    <ul>
      <li>each internal array is a ‘solution’ — a list of <strong>n</strong> throws</li>
      <li>outer array must contain <em>all</em> possible solutions</li>
    </ul>
  </li>
</ul>

<p>We can think about this problem as another interaction with a decision tree. We start with an empty state (<code>[]</code>), and then we fill that state with all possible permutations of <strong>n</strong> throws. We can get an exhaustive list of possible permutations by doing a depth-first-search of a decision tree. Each node represents either a ‘rock’, ‘paper’, or ‘scissor’ throw. We crawl the tree up and down, and each time we get to the end of a branch, we know that we have found a valid solution.</p>

<p>Here is the code, which I will explain below.</p>

<script src="https://gist.github.com/Cfeusier/a0c246225f87dcbf722e.js"></script>

<p>We are using a common pattern when working with trees, where we use a recursive subroutine within our solver function.</p>

<p>We start by taking a number of <em>rounds</em> as input — rounds is the number of times the single player makes a throw in a valid solution.</p>

<p><img src="/img/blog/rockpaperscissors.png" /></p>

<p>If you look at the tree visualization above, you will see that we start by pushing a ‘rock’ throw into the <em>thrown</em> array. Before we go any further across the tree, we go <strong>down</strong> the tree with recursion. This happens on line 16, where we recurse with 1 less round of throws.</p>

<p>The recursive call will now push another rock into the array, so we have <code>[ rock, rock ]</code> in our <strong>thrown</strong> array. Another recursive call will push ‘rock’ into our <strong>thrown</strong> array one more time, so that we have <code>[ rock, rock, rock ]</code> in our array.</p>

<p>Assuming that we only want our player to throw 3 times (rounds), we will then recurse a final time, passing <code>0</code> into our subroutine.</p>

<p>This time, when we enter the recursive call, our base case triggers — we have 0 rounds left to throw, so we know that we have found a valid solution. We have a solution with <code>[ rock, rock, rock ]</code> — we want to push a <strong>copy</strong> of that solution into our <code>outcomes</code> array in the closure scope. We need to push a copy of the <strong>thrown</strong> array, because we are going to go back <em>up</em> the tree one level and then find another solution based on that current decision constraint (i.e, <code>[ rock, rock, paper/scissors ]</code>).</p>

<p>This pattern of going down, then up and across, then down, then up and across, etc., will continue <strong>n</strong> times down, <strong>n times</strong> up, and <code>plays.length</code> times across. This pattern of movement through the tree is caused by looping <em>across</em> the possible <code>plays</code>, and recursing <code>down</code> <strong>n</strong> times for each <code>play</code>. Finally, once all of the possible states have been examined through a mixture of iteration and recursion, we know that we have all of our possible outcomes or solutions, so we just return that array of solution arrays.</p>

<p>Hopefully this relatively contrived example shows the value of a decision tree for system-state analysis and sequence analysis.</p>

<h2 id="summary">Summary</h2>

<ol>
  <li>trees are cool</li>
  <li>trees are node-based data structures
    <ul>
      <li>each node stores a value and a reference to zero or more children nodes</li>
      <li>a tree has a root node of which all the other nodes in the tree are ancestors</li>
      <li>every node is itself a tree, composed of subtrees</li>
    </ul>
  </li>
  <li>you can constrain trees to do what you want
    <ul>
      <li>number of children constraints: binary trees are the most common (each node can only have two children)</li>
      <li>insertion of data constraints: search trees are the most common (insert data based on a pattern to optimize search and retrieval)</li>
      <li>type or value of children constraints: decision trees are the most common (the type of node or value at a node is constrained by the values of ancestor nodes)</li>
    </ul>
  </li>
  <li>use recursion and smart base cases when working with trees</li>
</ol>

<h3 id="save-your-software-plant-a-tree">Save your software, plant a tree.</h3>


                </div>
            </div>
            <div class="post-tags">
                <i class="fa fa-tags"></i>
                
                <a class="tag_list_link" href="http://clarkfeusier.com/tag/javascript">javascript</a>
                <span class="seperator">,</span>
                
                <a class="tag_list_link" href="http://clarkfeusier.com/tag/data structures">data structures</a>
                <span class="seperator">,</span>
                
                <a class="tag_list_link" href="http://clarkfeusier.com/tag/implementation examples">implementation examples</a>
                <span class="seperator">,</span>
                
                <a class="tag_list_link" href="http://clarkfeusier.com/tag/tree">tree</a>
                <span class="seperator">,</span>
                
                <a class="tag_list_link" href="http://clarkfeusier.com/tag/binary tree">binary tree</a>
                <span class="seperator">,</span>
                
                <a class="tag_list_link" href="http://clarkfeusier.com/tag/search tree">search tree</a>
                <span class="seperator">,</span>
                
                <a class="tag_list_link" href="http://clarkfeusier.com/tag/decision tree">decision tree</a>
                <span class="seperator">,</span>
                
            </div>
            <ul class="post-socials">
                <li><a href="https://www.facebook.com/sharer/sharer.php?u=http://clarkfeusier.com/2015/01/04/tree-data-structure-simple-binary-search-decision/&t=Rollin' Trees, yo" target="_blank"><i class="fa fa-facebook"></i></a></li>
                <li><a href="https://twitter.com/intent/tweet?original_referer=http://clarkfeusier.com/2015/01/04/tree-data-structure-simple-binary-search-decision/&text=Rollin' Trees, yo&url=http://clarkfeusier.com/2015/01/04/tree-data-structure-simple-binary-search-decision/" target="_blank"><i class="fa fa-twitter"></i></a></li>
                <li><a href="https://plus.google.com/share?url=http://clarkfeusier.com/2015/01/04/tree-data-structure-simple-binary-search-decision/" target="_blank"><i class="fa fa-google-plus"></i></a></li>
            </ul>
        </div>
    </div>
    <div id="blog-pagination">
        <ul>
        	
            <li class="prev"><a href="http://clarkfeusier.com/2014/12/14/object-oriented-javascript-pseudo-classical-class/"><i class="fa fa-angle-left"></i><span>Prev</span></a></li>
            
            
            <li class="separator"></li>
            
            
            <li class="next"><a href="http://clarkfeusier.com/2015/01/08/simple-node-server-api/"><span>Next</span><i class="fa fa-angle-right"></i></a></li>
            
        </ul>
    </div>
</div>
 </div>
       <footer>
            <div id="footer-quote">
                <div class="container">
                    <div class="contents">
                        <div class="quote-icon">
                            <i class="fa fa-quote-right"></i>
                        </div>
                        <span class="quote-name">Percy Bysshe Shelley</span>
                        <div class="quote-text">
                            The soul's joy lies in <span class="colored-text">doing</span>.
                        </div>
                    </div>
                </div>
            </div>
            <div id="bottom">
                <div class="container foot">
                    <ul id="social-icons">
                        <li><a href="http://github.com/cfeusier"><i class="fa fa-github"></i></a></li>
                        <li><a href="http://twitter.com/clarkfeusier"><i class="fa fa-twitter"></i></a></li>
                        <li><a href="http://facebook.com/cfeusier"><i class="fa fa-facebook"></i></a></li>
                        <li><a href="http://linkedin.com/in/clarkfeusier"><i class="fa fa-linkedin"></i></a></li>
                    </ul>
                    <div id="copyright">© COPYRIGHT 2015 Clark Feusier</div>
                    <a id="home-circle" href="http://clarkfeusier.com"><i class="fa fa-home"></i></a>
                </div>
            </div>
       </footer>
       <script type="text/javascript" src="http://clarkfeusier.com/js/jquery-1.11.0.min.js"></script>
       <script type="text/javascript" src="http://clarkfeusier.com/js/header_glitter.js"></script>
    </body>
</html>