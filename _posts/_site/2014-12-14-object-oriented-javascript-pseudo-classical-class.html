<script src="https://gist.github.com/Cfeusier/601b17d046f3ea3d5b82.js"></script>

<ol>
  <li>benefit: only one instance of each method created regardless of how many instances of the object are created</li>
  <li>downside: less clear about <code>this</code> bindings and under-the-hood ‘magic’</li>
  <li>benefit?: act like Java people with ‘real’ classes, lolz</li>
  <li>under-the-hood:
    <ul>
      <li>a new object is created that is assigned to <code>this</code></li>
      <li><code>this</code> is returned if nothing else is explicitly returned from the constructor</li>
      <li>IF this constructor is invoked with the <code>new</code> keyword, then the constructor will delegate failed property lookups to the object at the .prototype property <strong><em>of the constructor</em></strong></li>
    </ul>
  </li>
</ol>

<ul>
  <li>lines 1 - 3: the constructor function
    <ul>
      <li>line 2: assign whatever properties you want to the new instance, which has been auto-bound to <code>this</code>, and will be returned at the end of the constructor automagically</li>
    </ul>
  </li>
  <li>lines 5 - 11: the method container object stored at the .prototype key of the constructor is being filled with methods
    <ul>
      <li>these methods will be available to the new instance via failed property lookup delegation to the object at the .prototype key of the constructor function (if the instance was created with the <code>new</code> keyword)</li>
    </ul>
  </li>
</ul>

<p>We can now create as many <code>Example</code> instances as we want, all with access to each method on the constructor’s prototype <em>property</em>, without having to store the methods themselves! It is as simple as <code>var example = new Example();</code>.</p>
